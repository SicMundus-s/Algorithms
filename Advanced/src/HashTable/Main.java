package HashTable;

import java.util.HashMap;
import java.util.Map;

public class Main {
    public static void main(String[] args) {
        Map<String, Integer> test = new HashMap<>();
        test.put("King", 11);
        test.put("king", 12);
        System.out.println(test.get("King"));
        /**
         * 1.хеш-функции — функции, преобразующей число из большего диапазона в число из меньшего диапазона
         * 2.Хеш-функция должна сжать диапазон ключей до размера массива. Для этого, применяется оператор вычисления остатка (%)
         * 3. Хеширование ключа в уже заполненную ячейку массива называется коллизией.
         * 4. Существует две основные схемы разрешения коллизий: открытая адресация и метод цепочек.
         *  При открытой адресации элементы данных, хешируемые в заполненную ячейку массива, размещаются в другой ячейке.
         *  В методе цепочек каждый элемент массива содержит связанный список. Все элементы данных, хешируемые в заданный индекс массива, вставляются в этот список
         */

        /**
         * Хэш таблица в java(8+) - пара ключ/значение.
         * 1. В первую очередь это массив односвязных списков(Бакетов - корзин). Индекс получаем из формулы: (n - 1) & hash.
         * Где n - количество элементов(односвязных списков) в массиве. hash получаем из метода HashCode. Представляет собой уникальный идентификатор.
         *
         * 2. Если длина связанного списка превышает пороговое значение (TREEIFY THRESHOLD == 8), связанный список преобразуется в красно-черное дерево,
         * а длина связанного списка меньше 6, красно-черное дерево преобразован обратно в связанный список
         *
         * 3. Исходя из того, что нам нужно избежать коллизий в связанных списках(иначе структура превратиться в линейную)
         * появился кКоэффициент нагрузки-это мера, которая решает, когда следует увеличить пропускную способность Карты.
         * Коэффициент загрузки по умолчанию составляет 75% от емкости. Как только значение проходит порог
         * Map, преобразуется так, чтобы в нем было примерно в два раза больше ведер, чем раньше. Это операция довольно затратная
         * так как требует перераспределения элементов по всем вёдрам(спискам)
         *
         * 4.Поиск, удаление проходит за время O(1), но как? - ключ используется для получения hashCode объекта, далее получаем
         * индекс(так как только индексу массива можно произвести такой быстрый поиск) по формуле -  (n - 1) & hash, проверяем ключ и выводим значение.
         * Если под индексом образовался связанный список, то время увеличится до O(n) где n - количество элементов в списке до нужного значения
         * тогда после нахождения индекса "идём" по связанному списку сверяя значения ключей.
         *
         * 5. Добавление работает примерно так же(см пункт 4) поиск индекса, если не занят - добавить. Если занят -
         * добавляем в односвязный список, предыдущему элементу присваиваем ссылку на новый элемент.
         * Условие* - ключи должны быть уникальными.
         *
         * 6. В итоге мы получаем структуру данных с очень быстрым поиском, добавлением и удалением, но могут возникнуть коллизии
         * и так же эффективность может вырождаться если все значения будут заноситься в один или несколько односвязных список,
         * а остальные будут пустые, чтобы этого избежать в методе hashcode используются математические операции(умножение на 31 например)
         * для получения более "размазанных" значений hash и впоследствии индексов в массиве.
         *
         * 7. Методы hashcode и equals - Каждый раз при переопределении equals() и hashCode() мы выбираем определенные поля объекта, которые в этих методах учитывались.
         * Контракт двух методов позволяет сравнивать объекты сначала по Хэш коду(так как сравнивать два числа гораздо быстрее)
         * и Equals, например, в случае коллизии, будет сравнивать объект по полям.
         *
         *
         */
    }
}
